# `skip`
#### Skip a given number of lines from the start of an input stream

This existed mostly because I found myself frequently doing:

```bash
something | head -n 20 ...
something | head -n 20 | tail -n 20 ...
something | head -n 40 | tail -n 20 ...
```

And the mental math is hard.

Instead, this is preferred:

```bash
something | head -n 20 ...
something | skip -n 20 | head -n 20 ...
something | skip -n 40 | head -n 20 ...
```

This also has the benefit unlike tail, that it will start
emitting very early, as opposed to at the end of IO.

I know the code looks really similar, but the amount of thinking
required to make sure the first does what I expect it to is a lot.

While the second hand allows for linear mental processing without
mental backtracking.

> take a stream, skip the first 20 elements, return the next 20 elements

Is much easier to understand than:

> take a stream, take the first 40 elements, then take the last 20 elements of that

### SEE ALSO

## tail

Turns out, GNU `tail` has this feature inbuilt, but the documentation pays
so little attention to it you could easily overlook it.

```bash
# Emits 9 to 100 as it starts at "line 10"
# which is 9.
seq 0 100 | tail -n +10
```

## head

GNU `head` has a similar complimentary function for "all but ... "

```bash
# Emits 0 .. 90 as it "omits the last 10 items"
seq 0 100 | head -n -10
```
