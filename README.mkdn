# `skip`
#### Skip a given number of lines from the start of an input stream

This existed mostly because I found myself frequently doing:

```bash
something | head -n 20 ...
something | head -n 20 | tail -n 20 ...
something | head -n 40 | tail -n 20 ...
```

And the mental math is hard.

Instead, this is preferred:

```bash
something | head -n 20 ...
something | skip -n 20 | head -n 20 ...
something | skip -n 40 | head -n 20 ...
```

This also has the benefit unlike tail, that it will start
emitting very early, as opposed to at the end of IO.

I know the code looks really similar, but the amount of thinking
required to make sure the first does what I expect it to is a lot.

While the second hand allows for linear mental processing without
mental backtracking.

> take a stream, skip the first 20 elements, return the next 20 elements

Is much easier to understand than:

> take a stream, take the first 40 elements, then take the last 20 elements of that

### SEE ALSO

## tail

Turns out, GNU `tail` has this feature inbuilt, but the documentation pays
so little attention to it you could easily overlook it.

```bash
perl -E 'say for A..Z' | cat -n | tail -n +2
#     2	B
#     3	C
#     4	D
#     5	E
#     6	F
#     7	G
#     8	H
#     9	I
#    10	J
#    11	K
#    12	L
#    13	M
#    14	N
#    15	O
#    16	P
#    17	Q
#    18	R
#    19	S
#    20	T
#    21	U
#    22	V
#    23	W
#    24	X
#    25	Y
#    26	Z
```

## head

GNU `head` has a similar complimentary function for "all but ... "

```bash
perl -E 'say for A..Z' | cat -n | head -n -2
#     1	A
#     2	B
#     3	C
#     4	D
#     5	E
#     6	F
#     7	G
#     8	H
#     9	I
#    10	J
#    11	K
#    12	L
#    13	M
#    14	N
#    15	O
#    16	P
#    17	Q
#    18	R
#    19	S
#    20	T
#    21	U
#    22	V
#    23	W
#    24	X
```
